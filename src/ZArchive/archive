import { useRef, useState, useEffect, Suspense } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import * as THREE from 'three';
import Loader from '../components/Loader'
import Sky from '../models/Sky'
import Room from '../models/Room'
import Bird from '../models/Bird'
import Plane from '../models/Plane'
import Navbar from '../components/Navbar';
import WebMobile from './WebMobile';

import HomeInfo from '../components/HomeInfo'
import { PerspectiveCamera } from '@react-three/drei';
import {Route, BrowserRouter as Router, Routes, Outlet} from 'react-router-dom';
  
// npm run dev

const Home = () => {
  const defaultCamera = useRef(new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000));
  const [cameraPosition, setCameraPosition] = useState([-18, 2, -6]);
  const [cameraLookAt, setCameraRotation] = useState([8, -6, -32]);
  // updateCameraPosition([-18, 0, -10]);
  // updateCameraLookAt([0, -24, -32]); center

  const updateCameraPosition = (newPosition) => {
    const [x, y, z] = newPosition;
    setCameraPosition(newPosition);
  }

  const updateCameraLookAt = (newRotation) => {
    const [x, y, z] = newRotation;
    setCameraRotation(newRotation);
  }

  useEffect(() => {
    // console.log(cameraPosition);
    // defaultCamera.current.lookAt(0, 0, 0);
  });


  const [ isRotating, setIsRotating ] = useState (false);
  const [currentStage, setCurrentStage] = useState(1);

  const adjustRoomForScreenSize = () => {
    let screenScale = null;
    let screenPosition = [0, -24, -32];
    let rotation = [0, 9.45, 0];

    if (window.innerWidth < 768) {
      screenScale = [0.9, 0.9, 0.9];
    }else {
      screenScale = [1, 1, 1];
    }
    return [screenScale, screenPosition, rotation];
  }

  const adjustPlaneForScreenSize = () => {
    let screenScale, screenPosition;

    if (window.innerWidth < 768) {
      screenScale = [1.5, 1.5, 1.5];
      screenPosition = [0, -1.5, 0];
    }else {
      screenScale = [3, 3, 3];
      screenPosition = [0, -4, -4];
    }
    return [screenScale, screenPosition];
  }

  const [RoomScale, RoomPosition, RoomRotation] = adjustRoomForScreenSize();
  const [planeScale, planePosition] = adjustPlaneForScreenSize();



  return (
    <section className="w-full h-screen relative">

      <div className="absolute top-5 left-0 right-0 z-10 flex items-center justify-center">
        { currentStage && <HomeInfo currentStage={currentStage}/> }
        <Navbar 
          updateCameraPosition={updateCameraPosition}
          updateCameraLookAt={updateCameraLookAt}
        />
        <WebMobile
          updateCameraPosition={updateCameraPosition}
          updateCameraLookAt={updateCameraLookAt}
        />
      </div>


      <Canvas 
      className={`w-full h-screen bg-transparent ${isRotating ? 'cursor-grabbing' : 'cursor-grab'}`}
      camera={defaultCamera.current}
      >
        <Suspense fallback={<Loader />}>
          <directionalLight position={[1, 1, 1]} intensity={1}/>
          <ambientLight intensity={0.25}/>
          <hemisphereLight skyColor="#b1e1ff" groundColor="#000000" intensity={1}/>
          {/* <Bird/> */}
          <Sky isRotating={isRotating}/>
          <Room
            position={RoomPosition}
            scale={RoomScale}
            rotation={RoomRotation}
            isRotating={isRotating}
            setIsRotating={setIsRotating}
            setCurrentStage={setCurrentStage}
            updateCameraPosition={updateCameraPosition}
            updateCameraLookAt={updateCameraLookAt}
            defaultCamera={defaultCamera.current}
          />
          {/* <Plane
            isRotating = {isRotating}
            planeScale={planeScale}
            planePosition={planePosition}
            rotation={[0, 20, 0]}
          /> */}

        </Suspense>
        <CanvasContent
          defaultCamera={defaultCamera}
          cameraPosition={cameraPosition}
          cameraLookAt={cameraLookAt}
          setCameraPosition={setCameraPosition}
          setCameraRotation={setCameraRotation}
          setIsRotating={setIsRotating}
          setCurrentStage={setCurrentStage}
        />
      </Canvas>
      <Outlet />
    </section>
  )
};

const CanvasContent = ({ defaultCamera, cameraPosition, cameraLookAt }) => {
  useFrame(() => {
    if (defaultCamera.current) {
      defaultCamera.current.position.lerp(new THREE.Vector3(...cameraPosition), 0.05);

      // Assuming cameraLookAt is an array containing the target Euler angles (in radians)
      // const targetRotation = new THREE.Euler().fromArray(cameraLookAt);

      // Smoothly interpolate towards the target rotation
      // defaultCamera.current.rotation.x = THREE.MathUtils.lerp(defaultCamera.current.rotation.x, targetRotation.x, 0.05);
      // defaultCamera.current.rotation.y = THREE.MathUtils.lerp(defaultCamera.current.rotation.y, targetRotation.y, 0.05);
      // defaultCamera.current.rotation.z = THREE.MathUtils.lerp(defaultCamera.current.rotation.z, targetRotation.z, 0.05);
      
      // Calculate the current look-at direction
      const currentDirection = new THREE.Vector3();
      defaultCamera.current.getWorldDirection(currentDirection);

      // Calculate the target look-at direction
      const targetDirection = new THREE.Vector3(...cameraLookAt).normalize();

      // Smoothly interpolate towards the target direction
      const intermediateDirection = new THREE.Vector3();
      intermediateDirection.lerpVectors(currentDirection, targetDirection, 0.05); // Adjust the interpolation factor as needed
      
      // Update the camera's orientation to look towards the intermediate direction
      defaultCamera.current.lookAt(defaultCamera.current.position.clone().add(intermediateDirection));

      // defaultCamera.current.lookAt(x, y, z);
    }
  });

  return null;
};

export default Home